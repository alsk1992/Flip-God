/**
 * Alert Delivery - Send alerts through configured channels
 *
 * Channels: webhook (HTTP POST), console (log), email (placeholder formatter)
 */

import { createLogger } from '../utils/logger';
import type { Alert, AlertDeliveryChannel, AlertDeliveryConfig } from './types';

const logger = createLogger('alert-delivery');

// =============================================================================
// MESSAGE FORMATTING
// =============================================================================

/**
 * Format an alert into a human-readable message.
 */
export function formatAlertMessage(alert: Alert): string {
  const timestamp = new Date(alert.createdAt).toLocaleString();
  const typeLabel = formatAlertType(alert.type);
  const lines: string[] = [];

  lines.push(`[${typeLabel}] ${alert.message}`);
  lines.push(`  Time: ${timestamp}`);

  if (alert.platform) {
    lines.push(`  Platform: ${alert.platform}`);
  }
  if (alert.productId) {
    lines.push(`  Product: ${alert.productId}`);
  }
  if (alert.oldValue != null && alert.newValue != null) {
    lines.push(`  Change: $${alert.oldValue.toFixed(2)} -> $${alert.newValue.toFixed(2)}`);
  } else if (alert.newValue != null) {
    lines.push(`  Value: ${alert.newValue}`);
  }
  if (alert.threshold != null) {
    lines.push(`  Threshold: ${alert.threshold}`);
  }

  return lines.join('\n');
}

/**
 * Format alert type into a display label.
 */
function formatAlertType(type: string): string {
  switch (type) {
    case 'price_drop': return 'PRICE DROP';
    case 'price_increase': return 'PRICE INCREASE';
    case 'stock_low': return 'LOW STOCK';
    case 'stock_out': return 'OUT OF STOCK';
    case 'back_in_stock': return 'BACK IN STOCK';
    case 'new_opportunity': return 'NEW OPPORTUNITY';
    default: return type.toUpperCase();
  }
}

/**
 * Format an alert for email delivery (returns formatted subject + body).
 */
export function formatAlertEmail(alert: Alert): { subject: string; body: string } {
  const typeLabel = formatAlertType(alert.type);
  const subject = `FlipAgent Alert: ${typeLabel}${alert.platform ? ` on ${alert.platform}` : ''}`;

  const body = [
    `FlipAgent Price Alert`,
    `${'='.repeat(40)}`,
    '',
    `Type: ${typeLabel}`,
    `Message: ${alert.message}`,
    '',
    alert.platform ? `Platform: ${alert.platform}` : null,
    alert.productId ? `Product ID: ${alert.productId}` : null,
    alert.oldValue != null ? `Previous Value: $${alert.oldValue.toFixed(2)}` : null,
    alert.newValue != null ? `Current Value: $${alert.newValue.toFixed(2)}` : null,
    alert.threshold != null ? `Threshold: ${alert.threshold}` : null,
    '',
    `Time: ${new Date(alert.createdAt).toLocaleString()}`,
    `Alert ID: ${alert.id}`,
    '',
    '---',
    'This alert was generated by FlipAgent.',
  ]
    .filter((line): line is string => line != null)
    .join('\n');

  return { subject, body };
}

// =============================================================================
// DELIVERY
// =============================================================================

/**
 * Deliver an alert through the specified channels.
 *
 * Channels:
 * - 'console': Logs the alert to the application logger
 * - 'webhook': POSTs JSON payload to a configured URL
 * - 'email': Formats the message (actual sending not implemented)
 */
export async function deliverAlert(
  alert: Alert,
  channels: AlertDeliveryConfig[],
): Promise<Array<{ channel: AlertDeliveryChannel; success: boolean; error?: string }>> {
  const results: Array<{ channel: AlertDeliveryChannel; success: boolean; error?: string }> = [];

  for (const config of channels) {
    try {
      switch (config.channel) {
        case 'console': {
          const message = formatAlertMessage(alert);
          logger.info({ alertId: alert.id, type: alert.type }, message);
          results.push({ channel: 'console', success: true });
          break;
        }

        case 'webhook': {
          if (!config.webhookUrl) {
            results.push({ channel: 'webhook', success: false, error: 'No webhook URL configured' });
            break;
          }

          try {
            const payload = {
              id: alert.id,
              type: alert.type,
              message: alert.message,
              productId: alert.productId,
              platform: alert.platform,
              oldValue: alert.oldValue,
              newValue: alert.newValue,
              threshold: alert.threshold,
              createdAt: alert.createdAt,
            };

            const response = await fetch(config.webhookUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
              signal: AbortSignal.timeout(10_000),
            });

            if (!response.ok) {
              const errorText = await response.text().catch(() => 'Unknown error');
              results.push({
                channel: 'webhook',
                success: false,
                error: `HTTP ${response.status}: ${errorText.slice(0, 200)}`,
              });
              logger.warn(
                { alertId: alert.id, status: response.status, url: config.webhookUrl },
                'Webhook delivery failed',
              );
            } else {
              results.push({ channel: 'webhook', success: true });
              logger.debug({ alertId: alert.id }, 'Webhook delivered');
            }
          } catch (err) {
            const errorMsg = err instanceof Error ? err.message : String(err);
            results.push({ channel: 'webhook', success: false, error: errorMsg });
            logger.error({ alertId: alert.id, err, url: config.webhookUrl }, 'Webhook delivery error');
          }
          break;
        }

        case 'email': {
          // Email delivery is a placeholder -- format the message but don't send
          const { subject, body } = formatAlertEmail(alert);
          logger.info(
            { alertId: alert.id, subject, to: config.emailTo ?? '(not configured)' },
            'Email alert formatted (delivery not implemented)',
          );
          // In a real implementation, you'd call an email service here
          results.push({ channel: 'email', success: true });
          // Suppress unused variable warning
          void body;
          break;
        }

        default: {
          results.push({
            channel: config.channel,
            success: false,
            error: `Unknown delivery channel: ${config.channel}`,
          });
        }
      }
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      results.push({ channel: config.channel, success: false, error: errorMsg });
      logger.error({ alertId: alert.id, channel: config.channel, err }, 'Alert delivery error');
    }
  }

  return results;
}
